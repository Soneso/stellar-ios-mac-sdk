# SEP-53: Sign and Verify Messages

Prove ownership of a Stellar Ed25519 keypair by signing arbitrary messages.

## Introduction

> **Note:** SEP-53 is currently in Draft status (v0.0.1). The specification may evolve before reaching final status.

[SEP-53](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md) defines a standard method for signing and verifying messages with Stellar keypairs. Use cases include:

- Authenticating users by proving key ownership
- Signing attestations or consent agreements
- Verifying signatures produced by other Stellar SDKs
- Creating provable off-chain statements

The protocol prepends the message with a fixed prefix (`"Stellar Signed Message:\n"`), hashes it with SHA-256, and signs the hash with Ed25519. This prefix provides domain separation, ensuring signed messages cannot be confused with Stellar transaction signatures.

## Quick start

Sign a message and verify the signature:

```swift
import stellarsdk

// Generate a random keypair
let keyPair = try KeyPair.generateRandomKeyPair()

// Sign a message
let signature = try keyPair.signMessage("I agree to the terms of service")

// Verify the signature
let isValid = try keyPair.verifyMessage("I agree to the terms of service", signature: signature)
print(isValid) // true
```

## API reference

All methods are defined on `KeyPair`.

### signMessage(_ message: [UInt8]) throws -> [UInt8]

Signs a binary message according to SEP-53.

- **Parameter** `message`: The raw bytes of the message to sign.
- **Returns**: A 64-byte Ed25519 signature.
- **Throws**: `Ed25519Error.missingPrivateKey` if this keypair has no private key.

### signMessage(_ message: String) throws -> [UInt8]

Signs a UTF-8 string message according to SEP-53. The string is converted to its UTF-8 byte representation, then signed as binary data.

- **Parameter** `message`: The string message to sign.
- **Returns**: A 64-byte Ed25519 signature.
- **Throws**: `Ed25519Error.missingPrivateKey` if this keypair has no private key.

### verifyMessage(_ message: [UInt8], signature: [UInt8]) throws -> Bool

Verifies a binary message signature according to SEP-53.

- **Parameter** `message`: The original message bytes.
- **Parameter** `signature`: The 64-byte Ed25519 signature to verify.
- **Returns**: `true` if the signature is valid, `false` otherwise.
- **Throws**: `Ed25519Error.invalidSignatureLength` if the signature is not exactly 64 bytes.

### verifyMessage(_ message: String, signature: [UInt8]) throws -> Bool

Verifies a UTF-8 string message signature according to SEP-53.

- **Parameter** `message`: The original string message (converted to UTF-8 internally).
- **Parameter** `signature`: The 64-byte Ed25519 signature to verify.
- **Returns**: `true` if the signature is valid, `false` otherwise.
- **Throws**: `Ed25519Error.invalidSignatureLength` if the signature is not exactly 64 bytes.

## Detailed usage

### Signing string messages

Sign a message and encode the signature for transmission. The raw signature is 64 bytes; encode it as base64 or hex depending on your use case.

```swift
import stellarsdk

let keyPair = try KeyPair(secretSeed: "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")

let message = "User consent granted at 2025-01-15T12:00:00Z"
let signature = try keyPair.signMessage(message)

// Encode as base64 for transmission
let base64Signature = Data(signature).base64EncodedString()
print("Signature: \(base64Signature)")

// Or encode as hex
let hexSignature = Data(signature).hexEncodedString()
print("Signature (hex): \(hexSignature)")
```

### Signing binary data

The message does not have to be text. You can sign any binary data such as file contents:

```swift
import stellarsdk

let keyPair = try KeyPair(secretSeed: "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")

// Sign raw binary data
let fileData: [UInt8] = Array(try Data(contentsOf: URL(fileURLWithPath: "document.pdf")))
let signature = try keyPair.signMessage(fileData)

let base64Signature = Data(signature).base64EncodedString()
print("Document signature: \(base64Signature)")
```

### Verification with public-key-only keypair

Verification requires only the public key. This is the typical server-side flow after receiving a signed message from a client:

```swift
import stellarsdk

// Create keypair from account ID only (no private key needed)
let publicKey = try KeyPair(accountId: "GABC...")

let message = "User consent granted at 2025-01-15T12:00:00Z"
let signature = Data(base64Encoded: receivedBase64Signature)!

let isValid = try publicKey.verifyMessage(message, signature: [UInt8](signature))

if isValid {
    print("Signature verified")
} else {
    print("Invalid signature")
}
```

### Handling verification failure

When verification returns `false`, several causes are possible:

```swift
import stellarsdk

let publicKey = try KeyPair(accountId: "GABC...")
let signature = [UInt8](Data(base64Encoded: receivedBase64Signature)!)

do {
    let isValid = try publicKey.verifyMessage(message, signature: signature)
    if !isValid {
        // Possible causes:
        // 1. Message was modified after signing
        // 2. Signature was corrupted in transit
        // 3. Wrong public key used for verification
        // 4. Signature was created for a different message
        print("Invalid signature")
    }
} catch Ed25519Error.invalidSignatureLength {
    // Signature is not 64 bytes
    print("Malformed signature")
}
```

## Protocol details

SEP-53 signing:

```
signature = Ed25519Sign(privateKey, SHA-256("Stellar Signed Message:\n" + message))
```

Verification:

```
valid = Ed25519Verify(publicKey, SHA-256("Stellar Signed Message:\n" + message), signature)
```

Steps:

1. Prepend the fixed prefix `"Stellar Signed Message:\n"` (24 bytes, UTF-8) to the message bytes.
2. Compute the SHA-256 hash of the concatenated result.
3. Sign (or verify) the 32-byte hash using Ed25519.

The prefix provides domain separation. A signed message can never be confused with a Stellar transaction signature, which operates on different payloads.

## Security notes

### Domain separation

The `"Stellar Signed Message:\n"` prefix ensures that SEP-53 signatures are distinct from Stellar transaction signatures. This prevents an attacker from tricking a user into signing a message that could be replayed as a valid transaction.

### Key ownership vs account control

A SEP-53 signature proves ownership of a specific Ed25519 keypair. It does NOT prove control over a Stellar account, which may require multiple signers or different threshold levels.

Considerations:

- **Multi-sig accounts**: One signature does not imply transaction authority.
- **Revoked signers**: The key may have been removed from the account.
- **Weight thresholds**: The key may lack sufficient weight for certain operations.

For operations requiring account control, verify the account's signer configuration on-chain.

### User confirmation

Always display the full message to the user before signing. Never auto-sign without user review. This prevents phishing attacks where users unknowingly sign malicious content.

### Public-key-only keypair behavior

`signMessage` throws `Ed25519Error.missingPrivateKey` if the keypair has no private key. Handle this error when working with keypairs that may be verification-only:

```swift
let publicOnly = try KeyPair(accountId: "GABC...")

do {
    let signature = try publicOnly.signMessage("test")
} catch Ed25519Error.missingPrivateKey {
    print("Keypair has no private key")
}
```

## Cross-SDK compatibility

SEP-53 signatures are interoperable across all Stellar SDKs that implement the specification. A signature created in one SDK can be verified in any other.

Compatible SDKs: Java, Python, Flutter, PHP, and this iOS/macOS SDK.

```swift
import stellarsdk

// Verify a signature produced by the Java, Python, Flutter, or PHP SDK
let publicKey = try KeyPair(accountId: "GABC...")
let message = "Cross-platform message"
let signature = [UInt8](Data(base64Encoded: signatureFromOtherSDK)!)

let isValid = try publicKey.verifyMessage(message, signature: signature)
if isValid {
    print("Verified across SDKs")
}
```

## Test vectors

These test vectors are taken from the SEP-53 specification. All use the same keypair.

**Seed:** `SAKICEVQLYWGSOJS4WW7HZJWAHZVEEBS527LHK5V4MLJALYKICQCJXMW`
**Account ID:** `GBXFXNDLV4LSWA4VB7YIL5GBD7BVNR22SGBTDKMO2SBZZHDXSKZYCP7L`

### ASCII message

```swift
let seed = "SAKICEVQLYWGSOJS4WW7HZJWAHZVEEBS527LHK5V4MLJALYKICQCJXMW"
let expectedAccountId = "GBXFXNDLV4LSWA4VB7YIL5GBD7BVNR22SGBTDKMO2SBZZHDXSKZYCP7L"
let message = "Hello, World!"

let keyPair = try KeyPair(secretSeed: seed)
assert(keyPair.accountId == expectedAccountId)

let signature = try keyPair.signMessage(message)
let hexSignature = Data(signature).hexEncodedString()

let expectedHex = "7cee5d6d885752104c85eea421dfdcb95abf01f1271d11c4bec3fcbd7874dccd6e2e98b97b8eb23b643cac4073bb77de5d07b0710139180ae9f3cbba78f2ba04"
assert(hexSignature == expectedHex, "ASCII test vector failed")

let isValid = try keyPair.verifyMessage(message, signature: signature)
assert(isValid, "ASCII verification failed")
```

### UTF-8 message (Japanese)

```swift
let seed = "SAKICEVQLYWGSOJS4WW7HZJWAHZVEEBS527LHK5V4MLJALYKICQCJXMW"
let message = "こんにちは、世界！"

let keyPair = try KeyPair(secretSeed: seed)
let signature = try keyPair.signMessage(message)
let hexSignature = Data(signature).hexEncodedString()

let expectedHex = "083536eb95ecf32dce59b07fe7a1fd8cf814b2ce46f40d2a16e4ea1f6cecd980e04e6fbef9d21f98011c785a81edb85f3776a6e7d942b435eb0adc07da4d4604"
assert(hexSignature == expectedHex, "UTF-8 test vector failed")

let isValid = try keyPair.verifyMessage(message, signature: signature)
assert(isValid, "UTF-8 verification failed")
```

### Binary data

```swift
let seed = "SAKICEVQLYWGSOJS4WW7HZJWAHZVEEBS527LHK5V4MLJALYKICQCJXMW"

// Binary data from base64
let messageData = Data(base64Encoded: "2zZDP1sa1BVBfLP7TeeMk3sUbaxAkUhBhDiNdrksaFo=")!
let message = [UInt8](messageData)

let keyPair = try KeyPair(secretSeed: seed)
let signature = try keyPair.signMessage(message)
let hexSignature = Data(signature).hexEncodedString()

let expectedHex = "540d7eee179f370bf634a49c1fa9fe4a58e3d7990b0207be336c04edfcc539ff8bd0c31bb2c0359b07c9651cb2ae104e4504657b5d17d43c69c7e50e23811b0d"
assert(hexSignature == expectedHex, "Binary test vector failed")

let isValid = try keyPair.verifyMessage(message, signature: signature)
assert(isValid, "Binary verification failed")
```

## References

- [SEP-53 Specification](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0053.md)
- [KeyPair Source Code](https://github.com/Soneso/stellar-ios-mac-sdk/blob/master/stellarsdk/stellarsdk/crypto/KeyPair.swift)
