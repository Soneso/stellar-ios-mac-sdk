# SEP-45: Web Authentication for Contract Accounts

This document describes how to use the Stellar iOS/macOS SDK's SEP-45 implementation to authenticate Soroban smart contract accounts (C... addresses).

## Overview

SEP-45 enables wallets and clients to prove control of a Soroban contract account by signing authorization entries provided by an anchor's authentication server. Upon successful authentication, the server returns a JWT token that can be used to access other SEP services (SEP-12 KYC, SEP-24 deposits/withdrawals, SEP-38 quotes, etc.).

**SEP-45 vs SEP-10:**
- SEP-45 is for contract accounts (C... addresses) only
- SEP-10 is for traditional Stellar accounts (G... and M... addresses)
- Services supporting all account types should implement both protocols

## How Contract Authentication Works

Understanding the authentication flow requires knowing how contract accounts differ from traditional accounts:

### Traditional Accounts (G...)
- Signers are defined on-chain in the account's signer list
- Authentication verifies signatures against on-chain signers

### Contract Accounts (C...)
- Contracts define their own authorization logic via `__check_auth`
- The contract stores authorized signers (e.g., in persistent storage)
- Authentication invokes `__check_auth` which validates provided signatures

### The SEP-45 Flow

1. **Client** requests a challenge from the server
2. **Server** returns authorization entries calling `web_auth_verify` on its web-auth contract
3. **Client** validates and signs the entries with keypairs registered in the contract
4. **Client** submits signed entries to server
5. **Server** simulates the transaction - this invokes the client contract's `__check_auth`
6. If `__check_auth` succeeds, **Server** returns a JWT token

## Prerequisites

Before using SEP-45:

1. **Server Configuration**: The service must have a stellar.toml with:
   - `WEB_AUTH_FOR_CONTRACTS_ENDPOINT`: URL for the authentication endpoint
   - `WEB_AUTH_CONTRACT_ID`: The server's web-auth contract address (C...)
   - `SIGNING_KEY`: The server's signing key (G...)

2. **Client Contract Requirements**: Your contract account must:
   - Be deployed on the Stellar network (testnet or pubnet)
   - Implement `__check_auth` to define authorization rules
   - Have the signer's public key registered in its storage

3. **Signer Keypairs**: You need the secret keys for the signers registered in your contract's `__check_auth` implementation

## Basic Usage

### Simple Authentication

```swift
import stellarsdk

// Your contract account (must be deployed and implement __check_auth)
let contractAccountId = "CCIBUCGPOHWMMMFPFTDWBSVHQRT4DIBJ7AD6BZJYDITBK2LCVBYW7HUQ"

// The signer keypair - its public key must be registered in your contract's __check_auth
let signerKeyPair = try KeyPair(secretSeed: "SXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX")

// Create WebAuthForContracts instance from domain (loads stellar.toml automatically)
let result = await WebAuthForContracts.from(
    domain: "testanchor.stellar.org",
    network: .testnet
)

switch result {
case .success(let webAuth):
    // Execute complete authentication flow
    let jwtResult = await webAuth.jwtToken(
        forContractAccount: contractAccountId,
        signers: [signerKeyPair]
    )

    switch jwtResult {
    case .success(let jwtToken):
        print("Authentication successful!")
        print("JWT Token: \(jwtToken)")
    case .failure(let error):
        print("Authentication failed: \(error)")
    }
case .failure(let error):
    print("WebAuth initialization error: \(error)")
}
```

### Manual Configuration

If you prefer not to load from stellar.toml:

```swift
import stellarsdk

let contractAccountId = "CCIBUCGPOHWMMMFPFTDWBSVHQRT4DIBJ7AD6BZJYDITBK2LCVBYW7HUQ"
let signerKeyPair = try KeyPair(secretSeed: "SXXXXX...")

let webAuth = try WebAuthForContracts(
    authEndpoint: "https://testanchor.stellar.org/auth",
    webAuthContractId: "CCALHRGH5RXIDJDRLPPG4ZX2S563TB2QKKJR4STWKVQCYB6JVPYQXHRG",
    serverSigningKey: "GBWMCCC3NHSKLAOJDBKKYW7SSH2PFTTNVFKWSGLWGDLEBKLOVP5JLBBP",
    serverHomeDomain: "testanchor.stellar.org",
    network: .testnet
)

let jwtResult = await webAuth.jwtToken(
    forContractAccount: contractAccountId,
    signers: [signerKeyPair]
)

switch jwtResult {
case .success(let jwtToken):
    print("JWT Token: \(jwtToken)")
case .failure(let error):
    print("Error: \(error)")
}
```

## Signature Expiration

Signatures include an expiration ledger for replay protection. Per SEP-45, this should be set to a near-future ledger.

### Automatic Expiration (Default)

When you don't specify an expiration ledger, the SDK automatically:
1. Fetches the current ledger from Soroban RPC
2. Sets expiration to current ledger + 10 (approximately 50-60 seconds)

```swift
// Expiration is auto-filled (current ledger + 10)
let jwtResult = await webAuth.jwtToken(
    forContractAccount: contractAccountId,
    signers: [signerKeyPair]
)
```

### Custom Expiration

For specific requirements, you can set a custom expiration:

```swift
let customExpirationLedger: UInt32 = 1000000

let jwtResult = await webAuth.jwtToken(
    forContractAccount: contractAccountId,
    signers: [signerKeyPair],
    signatureExpirationLedger: customExpirationLedger
)
```

## Contracts Without Signature Requirements

Some contracts may implement `__check_auth` without requiring signature verification (e.g., contracts using other authorization mechanisms). Per SEP-45, client signatures are optional in such cases.

For these contracts, pass an empty signers array:

```swift
// Empty signers array - no signatures will be added
let jwtResult = await webAuth.jwtToken(
    forContractAccount: contractAccountId,
    signers: []  // No signers needed
)
```

When the signers array is empty, the SDK skips the Soroban RPC call since no signature expiration is needed.

**Note:** This only works if the server's anchor and your contract both support signature-less authentication. Most production contracts require signatures.

## Client Domain Verification

Non-custodial wallets can prove their domain to the anchor. This requires:
1. A stellar.toml on your domain with a `SIGNING_KEY`
2. The keypair for that signing key

### Local Signing

```swift
let contractAccountId = "CCIBUCGPOHWMMMFPFTDWBSVHQRT4DIBJ7AD6BZJYDITBK2LCVBYW7HUQ"
let signerKeyPair = try KeyPair(secretSeed: "SXXXXX...")

// Your wallet's SIGNING_KEY from stellar.toml
let clientDomainKeyPair = try KeyPair(secretSeed: "SYYYYY...")

let result = await WebAuthForContracts.from(
    domain: "testanchor.stellar.org",
    network: .testnet
)

switch result {
case .success(let webAuth):
    let jwtResult = await webAuth.jwtToken(
        forContractAccount: contractAccountId,
        signers: [signerKeyPair],
        homeDomain: "testanchor.stellar.org",
        clientDomain: "wallet.example.com",
        clientDomainAccountKeyPair: clientDomainKeyPair
    )
case .failure(let error):
    print("Error: \(error)")
}
```

### Remote Signing via Callback

If the client domain signing key is on a remote server:

```swift
func clientDomainSigningCallback(_ entry: SorobanAuthorizationEntryXDR) async throws -> SorobanAuthorizationEntryXDR {
    // entry is the client domain SorobanAuthorizationEntryXDR to sign
    // Send to your remote signing service and return the signed entry

    // Example: encode to base64 XDR, send to server, decode response
    let encodedBytes = try XDREncoder.encode(entry)
    let base64Xdr = Data(encodedBytes).base64EncodedString()

    // POST to your signing service
    var request = URLRequest(url: URL(string: "https://your-signer.example.com/sign-sep-45")!)
    request.httpMethod = "POST"
    request.setValue("application/json", forHTTPHeaderField: "Content-Type")

    let requestBody = [
        "authorization_entry": base64Xdr,
        "network_passphrase": "Test SDF Network ; September 2015"
    ]
    request.httpBody = try JSONSerialization.data(withJSONObject: requestBody)

    let (data, _) = try await URLSession.shared.data(for: request)
    let response = try JSONSerialization.jsonObject(with: data) as! [String: Any]
    let signedXdr = response["authorization_entry"] as! String

    guard let xdrData = Data(base64Encoded: signedXdr) else {
        throw NSError(domain: "SEP45", code: -1, userInfo: [NSLocalizedDescriptionKey: "Invalid base64"])
    }

    let xdrDecoder = XDRDecoder(data: xdrData)
    return try SorobanAuthorizationEntryXDR(from: xdrDecoder)
}

let jwtResult = await webAuth.jwtToken(
    forContractAccount: contractAccountId,
    signers: [signerKeyPair],
    homeDomain: "testanchor.stellar.org",
    clientDomain: "wallet.example.com",
    clientDomainSigningCallback: clientDomainSigningCallback
)
```

## Step-by-Step Authentication

For more control, execute each step individually:

```swift
import stellarsdk

let contractAccountId = "CCIBUCGPOHWMMMFPFTDWBSVHQRT4DIBJ7AD6BZJYDITBK2LCVBYW7HUQ"
let signerKeyPair = try KeyPair(secretSeed: "SXXXXX...")
let homeDomain = "testanchor.stellar.org"

let result = await WebAuthForContracts.from(domain: homeDomain, network: .testnet)

switch result {
case .success(let webAuth):
    // Step 1: Get challenge from server
    let challengeResult = await webAuth.getChallenge(
        forContractAccount: contractAccountId,
        homeDomain: homeDomain
    )

    switch challengeResult {
    case .success(let challengeResponse):
        do {
            // Step 2: Decode authorization entries from base64 XDR
            let authEntries = try webAuth.decodeAuthorizationEntries(
                base64Xdr: challengeResponse.authorizationEntries
            )

            // Step 3: Validate challenge
            try webAuth.validateChallenge(
                authEntries: authEntries,
                clientAccountId: contractAccountId,
                homeDomain: homeDomain
            )

            // Step 4: Get current ledger for signature expiration
            let sorobanServer = SorobanServer(endpoint: "https://soroban-testnet.stellar.org")
            let latestLedgerResult = await sorobanServer.getLatestLedger()

            switch latestLedgerResult {
            case .success(let latestLedgerResponse):
                let signatureExpirationLedger = latestLedgerResponse.sequence + 10

                // Step 5: Sign authorization entries
                let signedEntries = try await webAuth.signAuthorizationEntries(
                    authEntries: authEntries,
                    clientAccountId: contractAccountId,
                    signers: [signerKeyPair],
                    signatureExpirationLedger: signatureExpirationLedger,
                    clientDomainKeyPair: nil,
                    clientDomainAccountId: nil,
                    clientDomainSigningCallback: nil
                )

                // Step 6: Submit signed entries for JWT token
                let submitResult = await webAuth.sendSignedChallenge(signedEntries: signedEntries)

                switch submitResult {
                case .success(let jwtToken):
                    print("JWT Token: \(jwtToken)")
                case .failure(let error):
                    print("Submit error: \(error)")
                }
            case .failure(let error):
                print("Ledger error: \(error)")
            }
        } catch {
            print("Error: \(error)")
        }
    case .failure(let error):
        print("Challenge error: \(error)")
    }
case .failure(let error):
    print("WebAuth error: \(error)")
}
```

## Error Handling

The SDK provides specific error types for different failure scenarios:

```swift
import stellarsdk

let result = await WebAuthForContracts.from(
    domain: "testanchor.stellar.org",
    network: .testnet
)

switch result {
case .success(let webAuth):
    let jwtResult = await webAuth.jwtToken(
        forContractAccount: contractAccountId,
        signers: [signerKeyPair]
    )

    switch jwtResult {
    case .success(let jwtToken):
        print("Success: \(jwtToken)")

    case .failure(let error):
        // Handle specific error types
        switch error {
        case .validationError(let validationError):
            // Challenge validation errors
            switch validationError {
            case .invalidContractAddress(let expected, let received):
                print("Security error - contract address mismatch")
                print("Expected: \(expected), Received: \(received)")

            case .subInvocationsFound:
                print("Security error - sub-invocations detected")

            case .invalidServerSignature:
                print("Security error - invalid server signature")

            case .missingServerEntry:
                print("Invalid challenge - missing server entry")

            case .missingClientEntry:
                print("Invalid challenge - missing client entry")

            default:
                print("Validation error: \(validationError)")
            }

        case .challengeRequestError(let message):
            print("Challenge request failed: \(message)")

        case .submitChallengeError(let message):
            // Common cause: signer not registered in contract's __check_auth
            print("Authentication failed: \(message)")

        case .submitChallengeTimeout:
            print("Submit challenge timed out (HTTP 504)")

        default:
            print("Error: \(error)")
        }
    }
case .failure(let error):
    print("WebAuth initialization error: \(error)")
}
```

## Security Considerations

1. **Contract Address Validation**: The SDK verifies that `contract_address` in all authorization entries matches the `WEB_AUTH_CONTRACT_ID` from stellar.toml

2. **No Sub-Invocations**: The SDK rejects challenges containing sub-invocations, which could authorize unintended operations

3. **Server Signature Verification**: The SDK verifies the server has signed the challenge with the key from stellar.toml

4. **Function Name Validation**: Only `web_auth_verify` function is accepted

5. **Signature Expiration**: The SDK automatically sets tight expiration windows (current ledger + 10) to minimize replay attack windows

6. **Nonce Consistency**: The SDK verifies the nonce is consistent across all authorization entries

7. **Network Passphrase**: When provided by the server, the SDK validates the network passphrase matches

8. **JWT Storage**: Store JWT tokens securely. Never expose them in logs, URLs, or insecure storage

## Using JWT Tokens

Once authenticated, use the JWT token with other SEP services:

```swift
import Foundation

let jwtToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

// Example: SEP-12 KYC request
var request = URLRequest(url: URL(string: "https://testanchor.stellar.org/kyc/customer")!)
request.setValue("Bearer \(jwtToken)", forHTTPHeaderField: "Authorization")

let (data, response) = try await URLSession.shared.data(for: request)
let customerInfo = try JSONSerialization.jsonObject(with: data) as? [String: Any]
```

## Network Support

```swift
import stellarsdk

// Testnet
let testnetResult = await WebAuthForContracts.from(
    domain: "testanchor.stellar.org",
    network: .testnet
)

// Public network (mainnet)
let publicResult = await WebAuthForContracts.from(
    domain: "anchor.stellar.org",
    network: .public
)
```

## Reference Contracts

For SEP-45 authentication, the client contract must implement `__check_auth` to define authorization rules. The Stellar Anchor Platform provides a reference implementation:

- [Account Contract](https://github.com/stellar/anchor-platform/tree/main/soroban/contracts/account) - A sample client contract that implements `__check_auth` with Ed25519 signature verification. This contract stores authorized signers in persistent storage and validates signatures during authentication.

## Reference

- [SEP-45 Specification](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0045.md)
- [Stellar iOS/macOS SDK](https://github.com/Soneso/stellar-ios-mac-sdk)
- [SEP-10 (for traditional accounts)](https://github.com/stellar/stellar-protocol/blob/master/ecosystem/sep-0010.md)
