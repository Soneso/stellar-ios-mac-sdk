//
// This file was generated by stellar_contract_bindings v0.5.0b0
// and stellar_sdk v13.0.0.
//
// @generated
//


import Foundation
import stellarsdk


/// Generated contract client for AtomicSwapContract
public class AtomicSwapContract {
    
    /// The underlying SorobanClient instance
    private let client: SorobanClient
    
    /// Private constructor that wraps a SorobanClient
    private init(client: SorobanClient) {
        self.client = client
    }
    
    /// Creates a new AtomicSwapContract for the given client options
    /// - Parameter options: Client options for the contract
    /// - Returns: A new AtomicSwapContract instance
    public static func forClientOptions(options: ClientOptions) async throws -> AtomicSwapContract {
        let client = try await SorobanClient.forClientOptions(options: options)
        return AtomicSwapContract(client: client)
    }
    
    /// Gets the contract ID
    /// - Returns: The contract ID as a string
    public var contractId: String {
        return client.contractId
    }
    
    /// Gets the spec entries of the contract
    /// - Returns: Array of SCSpecEntryXDR
    public var specEntries: [SCSpecEntryXDR] {
        return client.specEntries
    }
    
    /// Gets the method names of the contract
    /// - Returns: Array of method names
    public var methodNames: [String] {
        return client.methodNames
    }
    
    /// Invoke the swap method
    ///
    /// - Parameter a: SCAddressXDR
    /// - Parameter b: SCAddressXDR
    /// - Parameter token_a: SCAddressXDR
    /// - Parameter token_b: SCAddressXDR
    /// - Parameter amount_a: String
    /// - Parameter min_b_for_a: String
    /// - Parameter amount_b: String
    /// - Parameter min_a_for_b: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func swap(
        a: SCAddressXDR,
        b: SCAddressXDR,
        token_a: SCAddressXDR,
        token_b: SCAddressXDR,
        amount_a: String,
        min_b_for_a: String,
        amount_b: String,
        min_a_for_b: String,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(a),
            SCValXDR.address(b),
            SCValXDR.address(token_a),
            SCValXDR.address(token_b),
            try SCValXDR.i128(stringValue: amount_a),
            try SCValXDR.i128(stringValue: min_b_for_a),
            try SCValXDR.i128(stringValue: amount_b),
            try SCValXDR.i128(stringValue: min_a_for_b)
        ]
        
        _ = try await client.invokeMethod(
            name: "swap",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the swap method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter a: SCAddressXDR
    /// - Parameter b: SCAddressXDR
    /// - Parameter token_a: SCAddressXDR
    /// - Parameter token_b: SCAddressXDR
    /// - Parameter amount_a: String
    /// - Parameter min_b_for_a: String
    /// - Parameter amount_b: String
    /// - Parameter min_a_for_b: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildSwapTx(
        a: SCAddressXDR,
        b: SCAddressXDR,
        token_a: SCAddressXDR,
        token_b: SCAddressXDR,
        amount_a: String,
        min_b_for_a: String,
        amount_b: String,
        min_a_for_b: String,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(a),
            SCValXDR.address(b),
            SCValXDR.address(token_a),
            SCValXDR.address(token_b),
            try SCValXDR.i128(stringValue: amount_a),
            try SCValXDR.i128(stringValue: min_b_for_a),
            try SCValXDR.i128(stringValue: amount_b),
            try SCValXDR.i128(stringValue: min_a_for_b)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "swap",
            args: args,
            methodOptions: methodOptions
        )
    }
}

// MARK: - Error Types

/// Custom errors for AtomicSwapContract operations
/// These errors are thrown when:
/// - Converting between Swift types and SCVal XDR types fails
/// - Type validation fails during deserialization
/// - Contract invocation fails
enum AtomicSwapContractError: Error {
    /// Thrown when converting from SCVal to Swift types fails.
    /// This typically happens when:
    /// - The SCVal type doesn't match the expected type
    /// - Required fields are missing in structs
    /// - Union discriminants are unknown
    /// - Enum values are out of range
    case conversionFailed(message: String)
    
    /// Thrown when a contract method invocation fails.
    /// This can happen when:
    /// - The contract returns an error
    /// - The transaction fails to submit
    /// - Network or RPC errors occur
    case invokeFailed(message: String)
}
