//
// This file was generated by stellar_contract_bindings v0.4.1b0
// and stellar_sdk v13.0.0b0.
//
// @generated
//


import Foundation
import stellarsdk


/// Generated union AuthContractDataKey
public enum AuthContractDataKey {
    case Counter(SCAddressXDR)
    
    public func toSCVal() throws -> SCValXDR {
        switch self {
        case .Counter(let value):
            return .vec([
                .symbol("Counter"),
                SCValXDR.address(value)
            ])
        }
    }
    
    /// Converts an SCVal XDR value to a AuthContractDataKey union
    /// - Parameter val: The SCVal to convert (must be a vec with discriminant as first element)
    /// - Returns: The corresponding AuthContractDataKey case
    /// - Throws: AuthContractError.conversionFailed if:
    ///   - The SCVal is not a vec
    ///   - The vec is empty or missing the discriminant
    ///   - The discriminant is not a symbol or is unknown
    ///   - The number of elements doesn't match the expected case
    public static func fromSCVal(_ val: SCValXDR) throws -> AuthContractDataKey {
        guard case .vec(let vec) = val, let vec = vec, vec.count >= 1 else {
            throw AuthContractError.conversionFailed(message: "Invalid union value: expected vec with at least 1 element")
        }
        
        guard case .symbol(let kind) = vec[0] else {
            throw AuthContractError.conversionFailed(message: "Invalid union discriminant")
        }
        
        switch kind {
        case "Counter":
            guard vec.count == 2 else {
                throw AuthContractError.conversionFailed(message: "Invalid union value for Counter: expected 2 elements")
            }
            return .Counter(try vec[1].address ?? { throw AuthContractError.conversionFailed(message: "Missing or invalid address value") }())
        default:
            throw AuthContractError.conversionFailed(message: "Unknown union kind: \(kind)")
        }
    }
}

/// Generated contract client for AuthContract
public class AuthContract {
    
    /// The underlying SorobanClient instance
    private let client: SorobanClient
    
    /// Private constructor that wraps a SorobanClient
    private init(client: SorobanClient) {
        self.client = client
    }
    
    /// Creates a new AuthContract for the given client options
    /// - Parameter options: Client options for the contract
    /// - Returns: A new AuthContract instance
    public static func forClientOptions(options: ClientOptions) async throws -> AuthContract {
        let client = try await SorobanClient.forClientOptions(options: options)
        return AuthContract(client: client)
    }
    
    /// Gets the contract ID
    /// - Returns: The contract ID as a string
    public var contractId: String {
        return client.contractId
    }
    
    /// Gets the spec entries of the contract
    /// - Returns: Array of SCSpecEntryXDR
    public var specEntries: [SCSpecEntryXDR] {
        return client.specEntries
    }
    
    /// Gets the method names of the contract
    /// - Returns: Array of method names
    public var methodNames: [String] {
        return client.methodNames
    }
    
    /// Increment increments a counter for the user, and returns the value.
    ///
    /// - Parameter user: SCAddressXDR
    /// - Parameter value: UInt32
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: UInt32
    public func increment(
        user: SCAddressXDR,
        value: UInt32,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws -> UInt32 {
        let args: [SCValXDR] = [
            SCValXDR.address(user),
            SCValXDR.u32(value)
        ]
        
        let result = try await client.invokeMethod(
            name: "increment",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
        return try result.u32 ?? { throw AuthContractError.conversionFailed(message: "Missing or invalid u32 value") }()
    }
    
    /// Build an AssembledTransaction for the increment method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter user: SCAddressXDR
    /// - Parameter value: UInt32
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildIncrementTx(
        user: SCAddressXDR,
        value: UInt32,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(user),
            SCValXDR.u32(value)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "increment",
            args: args,
            methodOptions: methodOptions
        )
    }
}

// MARK: - Error Types

/// Custom errors for AuthContract operations
/// These errors are thrown when:
/// - Converting between Swift types and SCVal XDR types fails
/// - Type validation fails during deserialization
/// - Contract invocation fails
enum AuthContractError: Error {
    /// Thrown when converting from SCVal to Swift types fails.
    /// This typically happens when:
    /// - The SCVal type doesn't match the expected type
    /// - Required fields are missing in structs
    /// - Union discriminants are unknown
    /// - Enum values are out of range
    case conversionFailed(message: String)
    
    /// Thrown when a contract method invocation fails.
    /// This can happen when:
    /// - The contract returns an error
    /// - The transaction fails to submit
    /// - Network or RPC errors occur
    case invokeFailed(message: String)
}