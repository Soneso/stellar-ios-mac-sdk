//
// This file was generated by stellar_contract_bindings v0.5.0b0
// and stellar_sdk v13.0.0.
//
// @generated
//


import Foundation
import stellarsdk


/// Generated struct TokenContractAllowanceDataKey
public struct TokenContractAllowanceDataKey: Codable {
    public let from: SCAddressXDR
    public let spender: SCAddressXDR
    
    public init(
        from: SCAddressXDR,
        spender: SCAddressXDR
    ) {
        self.from = from
        self.spender = spender
    }
    
    public func toSCVal() throws -> SCValXDR {
        var mapEntries: [SCMapEntryXDR] = []
        mapEntries.append(SCMapEntryXDR(
            key: .symbol("from"),
            val: SCValXDR.address(from)
        ))
        mapEntries.append(SCMapEntryXDR(
            key: .symbol("spender"),
            val: SCValXDR.address(spender)
        ))
        return .map(mapEntries)
    }
    
    /// Converts an SCVal XDR value to a TokenContractAllowanceDataKey struct
    /// - Parameter val: The SCVal to convert (must be a map)
    /// - Returns: A new TokenContractAllowanceDataKey instance
    /// - Throws: TokenContractError.conversionFailed if the SCVal is not a map or required fields are missing
    public static func fromSCVal(_ val: SCValXDR) throws -> TokenContractAllowanceDataKey {
        guard case .map(let mapEntries) = val else {
            throw TokenContractError.conversionFailed(message: "Invalid SCVal type for TokenContractAllowanceDataKey")
        }
        
        var map: [String: SCValXDR] = [:]
        for entry in mapEntries ?? [] {
            if case .symbol(let key) = entry.key {
                map[key] = entry.val
            }
        }
        guard let field_0_val = map["from"] else {
            throw TokenContractError.conversionFailed(message: "Missing required field 'from' in TokenContractAllowanceDataKey")
        }
        guard let field_1_val = map["spender"] else {
            throw TokenContractError.conversionFailed(message: "Missing required field 'spender' in TokenContractAllowanceDataKey")
        }
        
        return TokenContractAllowanceDataKey(
            from: try field_0_val.address ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid address value") }(),
            spender: try field_1_val.address ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid address value") }()
        )
    }
}

/// Generated struct TokenContractAllowanceValue
public struct TokenContractAllowanceValue: Codable {
    public let amount: String
    public let expiration_ledger: UInt32
    
    public init(
        amount: String,
        expiration_ledger: UInt32
    ) {
        self.amount = amount
        self.expiration_ledger = expiration_ledger
    }
    
    public func toSCVal() throws -> SCValXDR {
        var mapEntries: [SCMapEntryXDR] = []
        mapEntries.append(SCMapEntryXDR(
            key: .symbol("amount"),
            val: try SCValXDR.i128(stringValue: amount)
        ))
        mapEntries.append(SCMapEntryXDR(
            key: .symbol("expiration_ledger"),
            val: SCValXDR.u32(expiration_ledger)
        ))
        return .map(mapEntries)
    }
    
    /// Converts an SCVal XDR value to a TokenContractAllowanceValue struct
    /// - Parameter val: The SCVal to convert (must be a map)
    /// - Returns: A new TokenContractAllowanceValue instance
    /// - Throws: TokenContractError.conversionFailed if the SCVal is not a map or required fields are missing
    public static func fromSCVal(_ val: SCValXDR) throws -> TokenContractAllowanceValue {
        guard case .map(let mapEntries) = val else {
            throw TokenContractError.conversionFailed(message: "Invalid SCVal type for TokenContractAllowanceValue")
        }
        
        var map: [String: SCValXDR] = [:]
        for entry in mapEntries ?? [] {
            if case .symbol(let key) = entry.key {
                map[key] = entry.val
            }
        }
        guard let field_0_val = map["amount"] else {
            throw TokenContractError.conversionFailed(message: "Missing required field 'amount' in TokenContractAllowanceValue")
        }
        guard let field_1_val = map["expiration_ledger"] else {
            throw TokenContractError.conversionFailed(message: "Missing required field 'expiration_ledger' in TokenContractAllowanceValue")
        }
        
        return TokenContractAllowanceValue(
            amount: try field_0_val.i128String ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid i128 value") }(),
            expiration_ledger: try field_1_val.u32 ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid u32 value") }()
        )
    }
}

/// Generated union TokenContractDataKey
public enum TokenContractDataKey {
    case Allowance(TokenContractAllowanceDataKey)
    case Balance(SCAddressXDR)
    case State(SCAddressXDR)
    case Admin
    
    public func toSCVal() throws -> SCValXDR {
        switch self {
        case .Allowance(let value):
            return .vec([
                .symbol("Allowance"),
                try value.toSCVal()
            ])
        case .Balance(let value):
            return .vec([
                .symbol("Balance"),
                SCValXDR.address(value)
            ])
        case .State(let value):
            return .vec([
                .symbol("State"),
                SCValXDR.address(value)
            ])
        case .Admin:
            return .vec([.symbol("Admin")])
        }
    }
    
    /// Converts an SCVal XDR value to a TokenContractDataKey union
    /// - Parameter val: The SCVal to convert (must be a vec with discriminant as first element)
    /// - Returns: The corresponding TokenContractDataKey case
    /// - Throws: TokenContractError.conversionFailed if:
    ///   - The SCVal is not a vec
    ///   - The vec is empty or missing the discriminant
    ///   - The discriminant is not a symbol or is unknown
    ///   - The number of elements doesn't match the expected case
    public static func fromSCVal(_ val: SCValXDR) throws -> TokenContractDataKey {
        guard case .vec(let vec) = val, let vec = vec, vec.count >= 1 else {
            throw TokenContractError.conversionFailed(message: "Invalid union value: expected vec with at least 1 element")
        }
        
        guard case .symbol(let kind) = vec[0] else {
            throw TokenContractError.conversionFailed(message: "Invalid union discriminant")
        }
        
        switch kind {
        case "Allowance":
            guard vec.count == 2 else {
                throw TokenContractError.conversionFailed(message: "Invalid union value for Allowance: expected 2 elements")
            }
            return .Allowance(try TokenContractAllowanceDataKey.fromSCVal(vec[1]))
        case "Balance":
            guard vec.count == 2 else {
                throw TokenContractError.conversionFailed(message: "Invalid union value for Balance: expected 2 elements")
            }
            return .Balance(try vec[1].address ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid address value") }())
        case "State":
            guard vec.count == 2 else {
                throw TokenContractError.conversionFailed(message: "Invalid union value for State: expected 2 elements")
            }
            return .State(try vec[1].address ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid address value") }())
        case "Admin":
            return .Admin
        default:
            throw TokenContractError.conversionFailed(message: "Unknown union kind: \(kind)")
        }
    }
}

/// Generated struct TokenContractTokenMetadata
public struct TokenContractTokenMetadata: Codable {
    public let decimal: UInt32
    public let name: String
    public let symbol: String
    
    public init(
        decimal: UInt32,
        name: String,
        symbol: String
    ) {
        self.decimal = decimal
        self.name = name
        self.symbol = symbol
    }
    
    public func toSCVal() throws -> SCValXDR {
        var mapEntries: [SCMapEntryXDR] = []
        mapEntries.append(SCMapEntryXDR(
            key: .symbol("decimal"),
            val: SCValXDR.u32(decimal)
        ))
        mapEntries.append(SCMapEntryXDR(
            key: .symbol("name"),
            val: SCValXDR.string(name)
        ))
        mapEntries.append(SCMapEntryXDR(
            key: .symbol("symbol"),
            val: SCValXDR.string(symbol)
        ))
        return .map(mapEntries)
    }
    
    /// Converts an SCVal XDR value to a TokenContractTokenMetadata struct
    /// - Parameter val: The SCVal to convert (must be a map)
    /// - Returns: A new TokenContractTokenMetadata instance
    /// - Throws: TokenContractError.conversionFailed if the SCVal is not a map or required fields are missing
    public static func fromSCVal(_ val: SCValXDR) throws -> TokenContractTokenMetadata {
        guard case .map(let mapEntries) = val else {
            throw TokenContractError.conversionFailed(message: "Invalid SCVal type for TokenContractTokenMetadata")
        }
        
        var map: [String: SCValXDR] = [:]
        for entry in mapEntries ?? [] {
            if case .symbol(let key) = entry.key {
                map[key] = entry.val
            }
        }
        guard let field_0_val = map["decimal"] else {
            throw TokenContractError.conversionFailed(message: "Missing required field 'decimal' in TokenContractTokenMetadata")
        }
        guard let field_1_val = map["name"] else {
            throw TokenContractError.conversionFailed(message: "Missing required field 'name' in TokenContractTokenMetadata")
        }
        guard let field_2_val = map["symbol"] else {
            throw TokenContractError.conversionFailed(message: "Missing required field 'symbol' in TokenContractTokenMetadata")
        }
        
        return TokenContractTokenMetadata(
            decimal: try field_0_val.u32 ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid u32 value") }(),
            name: try field_1_val.string ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid string value") }(),
            symbol: try field_2_val.string ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid string value") }()
        )
    }
}

/// Generated contract client for TokenContract
public class TokenContract {
    
    /// The underlying SorobanClient instance
    private let client: SorobanClient
    
    /// Private constructor that wraps a SorobanClient
    private init(client: SorobanClient) {
        self.client = client
    }
    
    /// Creates a new TokenContract for the given client options
    /// - Parameter options: Client options for the contract
    /// - Returns: A new TokenContract instance
    public static func forClientOptions(options: ClientOptions) async throws -> TokenContract {
        let client = try await SorobanClient.forClientOptions(options: options)
        return TokenContract(client: client)
    }
    
    /// Gets the contract ID
    /// - Returns: The contract ID as a string
    public var contractId: String {
        return client.contractId
    }
    
    /// Gets the spec entries of the contract
    /// - Returns: Array of SCSpecEntryXDR
    public var specEntries: [SCSpecEntryXDR] {
        return client.specEntries
    }
    
    /// Gets the method names of the contract
    /// - Returns: Array of method names
    public var methodNames: [String] {
        return client.methodNames
    }
    
    /// Invoke the mint method
    ///
    /// - Parameter to: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func mint(
        to: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(to),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        let result = try await client.invokeMethod(
            name: "mint",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the mint method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter to: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildMintTx(
        to: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(to),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "mint",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the set_admin method
    ///
    /// - Parameter new_admin: SCAddressXDR
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func setAdmin(
        new_admin: SCAddressXDR,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(new_admin)
        ]
        
        let result = try await client.invokeMethod(
            name: "set_admin",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the set_admin method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter new_admin: SCAddressXDR
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildSetAdminTx(
        new_admin: SCAddressXDR,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(new_admin)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "set_admin",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the allowance method
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter spender: SCAddressXDR
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: String
    public func allowance(
        from: SCAddressXDR,
        spender: SCAddressXDR,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws -> String {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            SCValXDR.address(spender)
        ]
        
        let result = try await client.invokeMethod(
            name: "allowance",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
        return try result.i128String ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid i128 value") }()
    }
    
    /// Build an AssembledTransaction for the allowance method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter spender: SCAddressXDR
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildAllowanceTx(
        from: SCAddressXDR,
        spender: SCAddressXDR,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            SCValXDR.address(spender)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "allowance",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the approve method
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter spender: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter expiration_ledger: UInt32
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func approve(
        from: SCAddressXDR,
        spender: SCAddressXDR,
        amount: String,
        expiration_ledger: UInt32,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            SCValXDR.address(spender),
            try SCValXDR.i128(stringValue: amount),
            SCValXDR.u32(expiration_ledger)
        ]
        
        let result = try await client.invokeMethod(
            name: "approve",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the approve method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter spender: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter expiration_ledger: UInt32
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildApproveTx(
        from: SCAddressXDR,
        spender: SCAddressXDR,
        amount: String,
        expiration_ledger: UInt32,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            SCValXDR.address(spender),
            try SCValXDR.i128(stringValue: amount),
            SCValXDR.u32(expiration_ledger)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "approve",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the balance method
    ///
    /// - Parameter id: SCAddressXDR
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: String
    public func balance(
        id: SCAddressXDR,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws -> String {
        let args: [SCValXDR] = [
            SCValXDR.address(id)
        ]
        
        let result = try await client.invokeMethod(
            name: "balance",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
        return try result.i128String ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid i128 value") }()
    }
    
    /// Build an AssembledTransaction for the balance method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter id: SCAddressXDR
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildBalanceTx(
        id: SCAddressXDR,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(id)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "balance",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the transfer method
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter to_muxed: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func transfer(
        from: SCAddressXDR,
        to_muxed: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            SCValXDR.address(to_muxed),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        let result = try await client.invokeMethod(
            name: "transfer",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the transfer method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter to_muxed: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildTransferTx(
        from: SCAddressXDR,
        to_muxed: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            SCValXDR.address(to_muxed),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "transfer",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the transfer_from method
    ///
    /// - Parameter spender: SCAddressXDR
    /// - Parameter from: SCAddressXDR
    /// - Parameter to: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func transferFrom(
        spender: SCAddressXDR,
        from: SCAddressXDR,
        to: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(spender),
            SCValXDR.address(from),
            SCValXDR.address(to),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        let result = try await client.invokeMethod(
            name: "transfer_from",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the transfer_from method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter spender: SCAddressXDR
    /// - Parameter from: SCAddressXDR
    /// - Parameter to: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildTransferFromTx(
        spender: SCAddressXDR,
        from: SCAddressXDR,
        to: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(spender),
            SCValXDR.address(from),
            SCValXDR.address(to),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "transfer_from",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the burn method
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func burn(
        from: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        let result = try await client.invokeMethod(
            name: "burn",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the burn method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter from: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildBurnTx(
        from: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(from),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "burn",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the burn_from method
    ///
    /// - Parameter spender: SCAddressXDR
    /// - Parameter from: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: Void
    public func burnFrom(
        spender: SCAddressXDR,
        from: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws {
        let args: [SCValXDR] = [
            SCValXDR.address(spender),
            SCValXDR.address(from),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        let result = try await client.invokeMethod(
            name: "burn_from",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
    }
    
    /// Build an AssembledTransaction for the burn_from method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter spender: SCAddressXDR
    /// - Parameter from: SCAddressXDR
    /// - Parameter amount: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildBurnFromTx(
        spender: SCAddressXDR,
        from: SCAddressXDR,
        amount: String,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.address(spender),
            SCValXDR.address(from),
            try SCValXDR.i128(stringValue: amount)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "burn_from",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the decimals method
    ///
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: UInt32
    public func decimals(
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws -> UInt32 {
        let args: [SCValXDR] = [
        ]
        
        let result = try await client.invokeMethod(
            name: "decimals",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
        return try result.u32 ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid u32 value") }()
    }
    
    /// Build an AssembledTransaction for the decimals method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildDecimalsTx(
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "decimals",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the name method
    ///
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: String
    public func name(
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws -> String {
        let args: [SCValXDR] = [
        ]
        
        let result = try await client.invokeMethod(
            name: "name",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
        return try result.string ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid string value") }()
    }
    
    /// Build an AssembledTransaction for the name method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildNameTx(
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "name",
            args: args,
            methodOptions: methodOptions
        )
    }
    
    /// Invoke the symbol method
    ///
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: String
    public func symbol(
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws -> String {
        let args: [SCValXDR] = [
        ]
        
        let result = try await client.invokeMethod(
            name: "symbol",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
        return try result.string ?? { throw TokenContractError.conversionFailed(message: "Missing or invalid string value") }()
    }
    
    /// Build an AssembledTransaction for the symbol method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildSymbolTx(
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "symbol",
            args: args,
            methodOptions: methodOptions
        )
    }
}

// MARK: - Error Types

/// Custom errors for TokenContract operations
/// These errors are thrown when:
/// - Converting between Swift types and SCVal XDR types fails
/// - Type validation fails during deserialization
/// - Contract invocation fails
enum TokenContractError: Error {
    /// Thrown when converting from SCVal to Swift types fails.
    /// This typically happens when:
    /// - The SCVal type doesn't match the expected type
    /// - Required fields are missing in structs
    /// - Union discriminants are unknown
    /// - Enum values are out of range
    case conversionFailed(message: String)
    
    /// Thrown when a contract method invocation fails.
    /// This can happen when:
    /// - The contract returns an error
    /// - The transaction fails to submit
    /// - Network or RPC errors occur
    case invokeFailed(message: String)
}
