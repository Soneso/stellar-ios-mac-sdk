//
// This file was generated by stellar_contract_bindings v0.5.0b0
// and stellar_sdk v13.0.0.
//
// @generated
//


import Foundation
import stellarsdk


/// Generated contract client for HelloContract
public class HelloContract {
    
    /// The underlying SorobanClient instance
    private let client: SorobanClient
    
    /// Private constructor that wraps a SorobanClient
    private init(client: SorobanClient) {
        self.client = client
    }
    
    /// Creates a new HelloContract for the given client options
    /// - Parameter options: Client options for the contract
    /// - Returns: A new HelloContract instance
    public static func forClientOptions(options: ClientOptions) async throws -> HelloContract {
        let client = try await SorobanClient.forClientOptions(options: options)
        return HelloContract(client: client)
    }
    
    /// Gets the contract ID
    /// - Returns: The contract ID as a string
    public var contractId: String {
        return client.contractId
    }
    
    /// Gets the spec entries of the contract
    /// - Returns: Array of SCSpecEntryXDR
    public var specEntries: [SCSpecEntryXDR] {
        return client.specEntries
    }
    
    /// Gets the method names of the contract
    /// - Returns: Array of method names
    public var methodNames: [String] {
        return client.methodNames
    }
    
    /// Invoke the hello method
    ///
    /// - Parameter to: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Parameter force: Force signing and sending even if it's a read call (default: false)
    /// - Returns: [String]
    public func hello(
        to: String,
        methodOptions: MethodOptions? = nil,
        force: Bool = false
    ) async throws -> [String] {
        let args: [SCValXDR] = [
            SCValXDR.symbol(to)
        ]
        
        let result = try await client.invokeMethod(
            name: "hello",
            args: args,
            force: force,
            methodOptions: methodOptions
        )
        return try result.vec?.compactMap { try $0.symbol ?? { throw HelloContractError.conversionFailed(message: "Missing or invalid symbol value") }() } ?? []
    }
    
    /// Build an AssembledTransaction for the hello method.
    /// This is useful if you need to manipulate the transaction before signing and sending.
    ///
    /// - Parameter to: String
    /// - Parameter methodOptions: Options for transaction (optional)
    /// - Returns: AssembledTransaction
    public func buildHelloTx(
        to: String,
        methodOptions: MethodOptions? = nil
    ) async throws -> AssembledTransaction {
        let args: [SCValXDR] = [
            SCValXDR.symbol(to)
        ]
        
        return try await client.buildInvokeMethodTx(
            name: "hello",
            args: args,
            methodOptions: methodOptions
        )
    }
}

// MARK: - Error Types

/// Custom errors for HelloContract operations
/// These errors are thrown when:
/// - Converting between Swift types and SCVal XDR types fails
/// - Type validation fails during deserialization
/// - Contract invocation fails
enum HelloContractError: Error {
    /// Thrown when converting from SCVal to Swift types fails.
    /// This typically happens when:
    /// - The SCVal type doesn't match the expected type
    /// - Required fields are missing in structs
    /// - Union discriminants are unknown
    /// - Enum values are out of range
    case conversionFailed(message: String)
    
    /// Thrown when a contract method invocation fails.
    /// This can happen when:
    /// - The contract returns an error
    /// - The transaction fails to submit
    /// - Network or RPC errors occur
    case invokeFailed(message: String)
}
